;;; xpra.el --- Making frames through xpra           -*- lexical-binding: t; -*-

;; Copyright (C) 2025  

;; Author: Spencer Baugh <sbaugh@catern.com>
;; Keywords: frames

;;; Commentary:

;; 

;;; Code:
(require 'comint)
(require 'bindat)

(defgroup xpra nil "Xpra-based web frames."
  :group 'environment)

(defcustom xpra-exe "/nix/store/krdplrwirm6j4p5iivrm32qxmzw7zhqi-xpra-6.2.3/bin/xpra"
  "The xpra executable."
  :type '(string))

(defcustom xpra-html "/nix/store/krdplrwirm6j4p5iivrm32qxmzw7zhqi-xpra-6.2.3/share/xpra/www"
  "The xpra-html5 client."
  :type '(string))

(defcustom xpra-additional-args
  '("--printing=no" "--webcam=no" "--mdns=no" "--pulseaudio=no" "--opengl=no"
    "--source=/dev/null" "--splash=no" "--http-scripts=all")
  "Additional args passed to xpra."
  :type '(repeat string))

(defcustom xpra-idle-timeout 30
  "Idle timeout for the xpra frames.

Set to 0 to disable."
  :type '(natnum))

(defcustom xpra-buffer-name "*xpra*"
  "Name for the xpra buffer."
  :type '(string))

(defcustom xpra-nginx-exe "nginx"
  "The nginx executable."
  :type '(string))

(defcustom xpra-ssl-port 10443
  "Port number for nginx to listen on."
  :type '(natnum))

(defcustom xpra-ssl-key nil
  "Filename of SSL key to use with xpra.

If nil, use self-signed certs."
  :type '(choice (file :must-match t)
		 (const :tag "Use self-signed." nil)))

(defcustom xpra-nginx-auth #'xpra-nginx-auth-basic
  "Nginx configuration for how to authenticate to non-public frames.

If a string, this is included in the non-public location stanza.
If a function, that function is called when Nginx is started to
generate that string."
  :type '(choice (string :tag "Hard-coded authentication config.")
		 (function :tag "Generate authentication config.")))

(defcustom xpra-ssl-cert nil
  "Filename of SSL cert to use with xpra.

If nil, use self-signed certs."
  :type '(choice (file :must-match t)
		 (const :tag "Use self-signed." nil)))

(defvar-local xpra--nginx-process nil)
(defvar-local xpra--fqdn nil)

(defvar xpra-password-bindat-spec
  (bindat-type
    (r0 sint 32 t)
    (r1 sint 32 t)
    (r2 sint 32 t)
    (r3 sint 32 t)))

(defun xpra--make-password ()
  "Return a 256-bit random base64 URL-safe string."
  (base64url-encode-string
   (bindat-pack xpra-password-bindat-spec
		`((r0 . ,(random t)) (r1 . ,(random t)) (r2 . ,(random t)) (r3 . ,(random t))))
   t))

(defun xpra--cd-to-dir ()
  (let ((dir (locate-user-emacs-file "xpra")))
    (make-directory dir t)
    (set-file-modes dir #o700)
    (setq default-directory dir)))

(defun xpra--buffer ()
  (with-current-buffer (get-buffer-create xpra-buffer-name)
    (unless (derived-mode-p 'comint-mode)
      (comint-mode)
      (xpra--cd-to-dir)
      (setq xpra--fqdn (string-trim (shell-command-to-string "hostname --fqdn"))))
    (current-buffer)))

(defun xpra-nginx-auth-basic ()
  (let ((htpasswd "htpasswd"))
    (unless (file-exists-p htpasswd)
      (write-region (format "%s:{PLAIN}%s" user-login-name (xpra--make-password))
		    nil htpasswd))
    "    auth_basic emacs;
    auth_basic_user_file htpasswd;"))

(defun xpra--nginx-start ()
  (interactive)
  (with-current-buffer (xpra--buffer)
    (when (process-live-p xpra--nginx-process)
      (kill-process xpra--nginx-process)
      (while (accept-process-output xpra--nginx-process))
      ;; wait out TCP time-wait, I guess
      (sit-for 0.2))
    ;; nginx must be in the xpra dir so that it can open the sockets.
    (let ((config-file "nginx.conf"))
      (write-region (concat "# Generated by xpra.el
error_log stderr;
daemon off;
pid nginx.pid;
events {}
http {
  map $time_iso8601 $time_xpra { ~^([^T]+)T(\\d\\d:\\d\\d:\\d\\d) '$1 $2'; }
  map $msec $just_msec { ~\\d+.(\\d+)$ $1; }
  log_format xpra '$time_xpra,$just_msec [$remote_addr - $remote_user] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\"';
  access_log /dev/stdout xpra;
  server {
    listen " (number-to-string xpra-ssl-port) " ssl;
    " (let (ssl-key
	    ssl-cert)
	(if (or xpra-ssl-key xpra-ssl-cert)
	    (setq ssl-key xpra-ssl-key ssl-cert xpra-ssl-cert)
	  (setq ssl-key "key.pem" ssl-cert "cert.pem")
	  (unless (file-exists-p ssl-key)
	    (message "Generating self-signed certs.")
	    (shell-command
	     (concat
	      "openssl req -x509 -newkey rsa:4096 -keyout " ssl-key " -out " ssl-cert
	      " -sha256 -days 3650 -nodes -subj /C=US/CN=" xpra--fqdn))))
	(cl-assert (file-exists-p ssl-key))
	(cl-assert (file-exists-p ssl-cert))
	(concat "ssl_certificate " ssl-cert ";
    ssl_certificate_key " ssl-key ";")) "
    proxy_redirect off;
    proxy_http_version 1.1;
    proxy_buffering off;
    proxy_cache_bypass $http_upgrade;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection Upgrade;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

location ~ ^/(emacs-[^/]+)(/.*)?$ {
    set $uri_path $2;
    if ($uri_path = \"\") { set $uri_path \"/\"; }
" (if (stringp xpra-nginx-auth) xpra-nginx-auth (funcall xpra-nginx-auth))
"
    proxy_pass http://unix:$1:$uri_path;
}

location ~ ^/(public-[^/]+)(/.*)?$ {
    set $uri_path $2;
    if ($uri_path = \"\") { set $uri_path \"/\"; }
    proxy_pass http://unix:$1:$uri_path;
}

    root " xpra-html ";
    location =/default-settings.txt { alias " (let ((settings-file "default-settings.txt"))
	(write-region "# Xpra HTML5 settings, generated by xpra.el
min-quality = 10
min-speed = 50
floating_menu = no
# because of https://github.com/Xpra-org/xpra-html5/issues/329
offscreen = no
" nil settings-file)
	settings-file)
    "; }
    location /js { types { application/javascript  js; } }
    location /css { types { text/css css; } }
    location /icons { types { image/png png; } }
}}
") nil config-file)
      (setq xpra--nginx-process
	    (make-process
	     :name "xpra-nginx"
	     :buffer (current-buffer)
	     :command `(,xpra-nginx-exe "-e" "/dev/stderr" "-p" "." "-c" ,config-file)
	     :connection-type 'pipe :noquery t)))))

(defun xpra--start (sockname &optional interactive)
  (with-current-buffer (xpra--buffer)
    ;; (unless (process-live-p xpra--nginx-process)
    ;;   (xpra--nginx-start))
    (let* ((url (format "https://%s:10443/%s" xpra--fqdn sockname)))
      (let ((process-environment
	     (append '("XPRA_EXPORT_MENU_DATA=false"
		       ;; Suppress the `server-create-dumb-terminal-frame' (buggy) behavior.
		       "TERM=notdumb")
		     process-environment)))
	(make-process
	 :name "xpra"
	 :buffer (current-buffer)
	 :command
	 `(,xpra-exe
	   "start"
	   ,@xpra-additional-args
	   "--daemon=no"
	   ,(format "--bind=%s" (expand-file-name sockname))
	   ,(format "--server-idle-timeout=%s" xpra-idle-timeout)
	   "--exit-with-children" "--terminate-children=yes"
	   "--start-child=emacsclient --frame-parameters='((fullscreen . fullboth))' --create-frame"
	   ,(format "--html=%s" xpra-html))
	 :connection-type 'pipe
	 :noquery t))
      (when interactive
	;; TODO we should print this message *after* receiving the frame connection...
	(message "Frame on %s" url)
	(kill-new url))
      url)))

(defun xpra-start-public (&optional interactive)
  (interactive "p")
  ;; This format matches the forwarding regex for [^/]+-x[^/]+ in `xpra--nginx-start'.
  (xpra--start (format "public-x%s" (xpra--make-password)) interactive))

(defun xpra-start-private (number)
  (interactive "p")
  (xpra--start (format "emacs-%s" number) number))

(defun xpra-shutdown ()
  (interactive)
  (with-current-buffer (xpra--buffer)
    (while-let ((proc (get-buffer-process (current-buffer))))
      (interrupt-process proc)
      (sleep-for .1)
      (delete-process proc))
    (erase-buffer)))

(provide 'xpra)
;;; xpra.el ends here
